import { NextRequest, NextResponse } from 'next/server'
import { headers } from 'next/headers'
import { stripe } from '@/lib/stripe/server'
import { createClient } from '@/lib/supabase/server'
import { syncStripeCustomerToCandidate } from '@/lib/stripe/customers'

const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET

export async function POST(req: NextRequest) {
  if (!webhookSecret) {
    console.error('Missing STRIPE_WEBHOOK_SECRET')
    return new NextResponse('Webhook secret not configured', { status: 500 })
  }

  const body = await req.text()
  const headersList = await headers()
  const signature = headersList.get('stripe-signature')

  if (!signature) {
    console.error('Missing stripe-signature header')
    return new NextResponse('Missing signature', { status: 400 })
  }

  let event

  try {
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret)
  } catch (err) {
    console.error('Webhook signature verification failed:', err)
    return new NextResponse('Invalid signature', { status: 400 })
  }

  console.log('Received Stripe webhook:', event.type)

  try {
    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutSessionCompleted(event.data.object)
        break

      case 'payment_intent.succeeded':
        await handlePaymentIntentSucceeded(event.data.object)
        break

      case 'payment_intent.payment_failed':
        await handlePaymentIntentFailed(event.data.object)
        break

      case 'customer.created':
      case 'customer.updated':
        await handleCustomerUpdated(event.data.object)
        break

      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object)
        break

      default:
        console.log(`Unhandled event type: ${event.type}`)
    }

    return new NextResponse('Webhook processed successfully', { status: 200 })
  } catch (error) {
    console.error('Error processing webhook:', error)
    return new NextResponse('Webhook processing failed', { status: 500 })
  }
}

async function handleCheckoutSessionCompleted(session: any) {
  console.log('Processing checkout session completed:', session.id)

  const supabase = await createClient()

  try {
    // Get line items from the session
    const lineItems = await stripe.checkout.sessions.listLineItems(session.id, {
      expand: ['data.price.product']
    })

    // Create order record
    const orderData = {
      order_number: null, // Will be auto-generated by trigger
      customer_email: session.customer_details?.email || '',
      customer_name: session.customer_details?.name || '',
      customer_phone: session.customer_details?.phone || null,
      billing_address: session.customer_details?.address ? {
        address1: session.customer_details.address.line1,
        address2: session.customer_details.address.line2,
        city: session.customer_details.address.city,
        province: session.customer_details.address.state,
        zip: session.customer_details.address.postal_code,
        country: session.customer_details.address.country
      } : null,
      subtotal_amount: (session.amount_subtotal || 0) / 100, // Convert from cents
      tax_amount: (session.total_details?.amount_tax || 0) / 100,
      discount_amount: (session.total_details?.amount_discount || 0) / 100,
      total_amount: (session.amount_total || 0) / 100,
      currency: session.currency?.toLowerCase() || 'usd',
      stripe_checkout_session_id: session.id,
      stripe_payment_intent_id: session.payment_intent,
      status: 'paid',
      payment_status: 'succeeded',
      fulfillment_status: 'pending',
      notes: `Created from Stripe checkout session ${session.id}`
    }

    // Find or link to existing candidate
    if (session.customer_details?.email) {
      const { data: candidate } = await supabase
        .from('candidates')
        .select('id')
        .eq('email', session.customer_details.email.toLowerCase())
        .single()

      if (candidate) {
        orderData.candidate_id = candidate.id
      }
    }

    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert(orderData)
      .select('id, order_number')
      .single()

    if (orderError) {
      console.error('Error creating order:', orderError)
      return
    }

    console.log(`Created order: ${order.order_number}`)

    // Create order items
    const orderItems = []
    for (const item of lineItems.data) {
      const product = item.price?.product as any

      // Find our product by Stripe product ID
      const { data: dbProduct } = await supabase
        .from('products')
        .select('id, name')
        .eq('stripe_product_id', product.id)
        .single()

      orderItems.push({
        order_id: order.id,
        product_id: dbProduct?.id || null,
        name: product.name || item.description,
        description: product.description,
        quantity: item.quantity || 1,
        unit_price: (item.price?.unit_amount || 0) / 100,
        total_price: ((item.price?.unit_amount || 0) * (item.quantity || 1)) / 100,
        product_snapshot: {
          stripe_product_id: product.id,
          stripe_price_id: item.price?.id,
          original_data: item
        }
      })
    }

    if (orderItems.length > 0) {
      const { error: itemsError } = await supabase
        .from('order_items')
        .insert(orderItems)

      if (itemsError) {
        console.error('Error creating order items:', itemsError)
      } else {
        console.log(`Created ${orderItems.length} order items`)
      }
    }

    // Sync customer data if needed
    if (session.customer) {
      await syncStripeCustomerToCandidate(session.customer)
    }

  } catch (error) {
    console.error('Error processing checkout session:', error)
  }
}

async function handlePaymentIntentSucceeded(paymentIntent: any) {
  console.log('Payment intent succeeded:', paymentIntent.id)

  const supabase = await createClient()

  // Update order status
  await supabase
    .from('orders')
    .update({
      payment_status: 'succeeded',
      status: 'paid',
      paid_at: new Date().toISOString()
    })
    .eq('stripe_payment_intent_id', paymentIntent.id)
}

async function handlePaymentIntentFailed(paymentIntent: any) {
  console.log('Payment intent failed:', paymentIntent.id)

  const supabase = await createClient()

  // Update order status
  await supabase
    .from('orders')
    .update({
      payment_status: 'failed',
      status: 'cancelled'
    })
    .eq('stripe_payment_intent_id', paymentIntent.id)
}

async function handleCustomerUpdated(customer: any) {
  console.log('Customer updated:', customer.id)

  try {
    await syncStripeCustomerToCandidate(customer.id)
  } catch (error) {
    console.error('Error syncing customer:', error)
  }
}

async function handleInvoicePaymentSucceeded(invoice: any) {
  console.log('Invoice payment succeeded:', invoice.id)

  const supabase = await createClient()

  // Update order if this is linked to an order
  if (invoice.metadata?.order_id) {
    await supabase
      .from('orders')
      .update({
        payment_status: 'succeeded',
        status: 'paid',
        paid_at: new Date().toISOString()
      })
      .eq('id', invoice.metadata.order_id)
  }
}